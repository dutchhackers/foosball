import * as express from 'express';
import * as moment from 'moment';
import { Firestore } from '../utils/firestore-db';

import { WebClient } from '@slack/web-api';
import { SLACK_OAUTH_ACCESS_TOKEN, SLACK_DEDICATED_CHANNEL } from '../utils/config';
import { SlackHelper, addViewedBySnippetToBlock } from '../utils/slack-helper';
import { MatchService } from '../services/match-service';
import { IFinalScore, Callback, IOption } from '../models';
import { PlayerService } from '../services/player-service';
import { formatKroepnLeaderboardRow, parseSlackUser } from '../utils';
import { getPlayerCard } from '../views/slack';

const slackRouter = express.Router();

const client: WebClient = new WebClient(SLACK_OAUTH_ACCESS_TOKEN);

slackRouter.post('/foosball', async (req, res) => {
  const payload = req.body;
  console.log('[foosball] Received', payload);

  await SlackHelper.acknowledge(res);
  console.log('[foosball] Event Acknowledged');

  await client.dialog.open({
    trigger_id: payload.trigger_id,
    dialog: {
      callback_id: Callback.FOOSBALL_MATCH,
      title: 'Foosball Match',
      submit_label: 'Submit',
      // "notify_on_cancel": true,
      elements: [
        {
          label: 'Team 1 - Player 1',
          name: 'team1player1',
          type: 'select',
          data_source: 'external',
        },
        {
          label: 'Team 1 - Player 2',
          placeholder: '',
          name: 'team1player2',
          type: 'select',
          data_source: 'external',
          optional: true,
        },
        {
          label: 'Score Team 1',
          name: 'score1',
          type: 'text',
          subtype: 'number',
        },
        {
          label: 'Team 2 - Player 1',
          name: 'team2player1',
          type: 'select',
          data_source: 'external',
        },
        {
          label: 'Team 2 - Player 2',
          placeholder: '',
          name: 'team2player2',
          type: 'select',
          data_source: 'external',
          optional: true,
        },
        {
          label: 'Score Team 2',
          name: 'score2',
          type: 'text',
          subtype: 'number',
        },
      ],
    },
  });
  console.log('[foosball] Dialog sent');
});

slackRouter.post('/update-me', async (req, res) => {
  const payload = req.body;
  console.log('[update-me] Received', payload);

  await SlackHelper.acknowledge(res);
  console.log('[update-me] Event Acknowledged');

  const { user_id } = payload;
  const playerService = new PlayerService(Firestore.db);
  const player = await playerService.getPlayerBySlackId(user_id);

  await client.dialog.open({
    trigger_id: payload.trigger_id,
    dialog: {
      callback_id: Callback.UPDATE_ME,
      title: 'Profile',
      submit_label: 'Save',
      // "notify_on_cancel": true,
      elements: [
        {
          label: 'Nickname',
          name: 'nickname',
          type: 'text',
          placeholder: 'Your nickname...',
          value: player.nickname,
          optional: true,
        },
        {
          label: 'Status',
          name: 'status',
          type: 'text',
          placeholder: 'Your status...',
          value: player.status,
          optional: true,
        },
        {
          label: 'Quote',
          name: 'quote',
          type: 'text',
          placeholder: 'Your quote...',
          value: player.quote,
          optional: true,
        },
      ],
    },
  });
  console.log('[update-me] Dialog sent');
});

slackRouter.post('/interactive', async (req, res) => {
  const payload = JSON.parse(req.body.payload);
  console.log('[interactive] Received', payload);

  const { user, submission, callback_id } = payload;

  const playerService = new PlayerService(Firestore.db);
  switch (callback_id) {
    case Callback.FOOSBALL_MATCH:
      const { team1player1, team1player2, team2player1, team2player2, score1, score2 } = submission;
      const errors = [];
      if (isNaN(score1)) {
        errors.push({
          name: 'score1',
          error: "Sorry, that ain't a number",
        });
      }
      if (isNaN(score2)) {
        errors.push({
          name: 'score2',
          error: "Sorry, that ain't a number",
        });
      }
      if (errors.length) {
        // Return with error messages
        return SlackHelper.send(res, { errors });
      }

      // Send ACK, to prevent time-out
      SlackHelper.acknowledge(res);

      const homeTeam = [team1player1];
      if (team1player2) homeTeam.push(team1player2);
      const awayTeam = [team2player1];
      if (team2player2) awayTeam.push(team2player2);
      const finalScore: IFinalScore = [parseInt(score1), parseInt(score2)];

      console.log('[interactive] Add match result', { homeTeam, awayTeam, finalScore });

      const matchService = new MatchService(Firestore.db);
      await matchService.addSimpleMatchResult(homeTeam, awayTeam, finalScore);

      const players = await playerService.getPlayersById([...homeTeam, ...awayTeam]);

      const homeTeamString = SlackHelper.concatPlayersString(homeTeam, players);
      const awayTeamString = SlackHelper.concatPlayersString(awayTeam, players);

      return client.chat.postMessage({
        channel: SLACK_DEDICATED_CHANNEL || payload.channel.id,
        text: SlackHelper.buildMatchResultString(homeTeamString, awayTeamString, finalScore),
      });
    case Callback.UPDATE_ME:
      const { nickname, status, quote } = submission;

      const player = await playerService.getPlayerBySlackId(user.id);
      await playerService.updatePlayer(player.id, { nickname, status, quote });
      await SlackHelper.acknowledge(res);
      return client.chat.postEphemeral({
        user: user.id,
        channel: payload.channel.id,
        text: SlackHelper.buildUpdateProfileString(player),
      });
      break;
  }
  return SlackHelper.acknowledge(res);
});

slackRouter.post('/options-load-endpoint', async (req, res) => {
  const payload = JSON.parse(req.body.payload);
  console.log('[options-load-endpoint] Received', payload);

  const { callback_id, name, value } = payload;
  // name: name of dialog field.
  // value: value entered by user.

  const options: IOption[] = [];

  switch (callback_id) {
    case Callback.FOOSBALL_MATCH:
      const playerOptions = await SlackHelper.getExternalDataOptions(Firestore.db, 'players');
      const filteredPlayerOptions = playerOptions.filter((option: IOption) => option.label.toLowerCase().indexOf(value.toLowerCase()) >= 0);
      options.push(...filteredPlayerOptions);
      break;
  }
  return SlackHelper.send(res, {
    options,
  });
});

slackRouter.post('/kroepn-leaderboard', async (req, res) => {
  const payload = req.body;
  console.log('[kroepn-leaderboard] Received', payload);

  await SlackHelper.acknowledge(res);
  console.log('[kroepn-leaderboard] Event Acknowledged');

  const timestamp = moment().add(-30, 'day'); // Filter on players who did play in the last N days
  const leaderboard = await SlackHelper.getDefaultLeaderboard(Firestore.db, { minDateLastMatch: timestamp.toISOString() });
  const rankingText = leaderboard.ranking.map(formatKroepnLeaderboardRow).join('\n');
  const rankingAsText = "*Kroep'n Leaderboard:* \n\n" + rankingText;

  const responseMessage: any = {
    channel: payload.channel_id,
    text: rankingAsText,
    mrkdwn: true,
    // blocks: [await getBlockRequestedBy(payload.user_id)],
  };

  return client.chat.postMessage(responseMessage);
});

slackRouter.post('/player-card', async (req, res) => {
  const payload = req.body;
  console.log('[player-card] Received', payload);

  await SlackHelper.acknowledge(res);
  console.log('[player-card] Event Acknowledged');

  try {
    const slackUser = parseSlackUser(payload.text);
    const playerService = new PlayerService(Firestore.db);
    const player = await playerService.getPlayerBySlackId(slackUser.id || payload.user_id);

    return client.chat.postMessage({
      channel: payload.channel_id,
      text: `View stats of ${player.displayName}`,
      blocks: addViewedBySnippetToBlock(getPlayerCard(player), payload.user_id),
      mrkdwn: true,
    });
  } catch (e) {
    console.log('[player-card] Error', e);
    return;
  }
});

async function getBlockRequestedBy(slackUserId: string): Promise<any> {
  console.log('[getBlockRequestedBy] Slack User Id', slackUserId);
  if (slackUserId) {
    try {
      const playerService = new PlayerService(Firestore.db);
      const user = await playerService.getPlayerBySlackId(slackUserId);

      return {
        type: 'context',
        elements: [
          {
            type: 'mrkdwn',
            text: `*Opgevraagd door:* ${user.name}`,
          },
        ],
      };
    } catch (e) {
      // Not Found
      console.log('[kroepn-leaderboard] Error', e);
      return undefined;
    }
  }
}

export { slackRouter };
